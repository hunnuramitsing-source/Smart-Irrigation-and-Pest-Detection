//Smart irrigation code
#include<LiquidCrystal_I2C.h>
#include<Wire.h>
#include<DHT.h>
#define dhtpin 9 
#define dhttype DHT11

DHT dht(dhtpin,dhttype);
LiquidCrystal_I2C lcd(0x27,16,2);

int sensor_pin=A0;
int relay_pin = 7;  
int SDA_pin=A4;
int SCL_pin=A5;       
int Buzzer=2;
int LED_pin=3;
int trigPin=13;
int echoPin=12;

void setup() {
  Serial.begin(9600);
  lcd.init();  // Initialize the LCD
  delay(50);   // Add a short delay
  lcd.backlight();
  dht.begin();
  pinMode(sensor_pin, INPUT);
  pinMode(relay_pin, OUTPUT);
  pinMode(echoPin,INPUT);
  pinMode(trigPin,OUTPUT);
  pinMode(Buzzer,OUTPUT);
  digitalWrite(relay_pin, HIGH);
  delay(100);
}
void loop() {
  int sensor_data = analogRead(sensor_pin);
  Serial.print("Sensor_data: MOISTURE = ");
  Serial.print(sensor_data);
  Serial.print("\t | ");
//dht sensor
float humi =dht.readHumidity();
float tempC=dht.readTemperature();
Serial.print("Humidity is : ");
Serial.print(humi);
Serial.print("%");
Serial.print("   |   ");
Serial.print("Temperature is : ");
Serial.print(tempC);
Serial.print(" Degree Celcius\n");
delay(1000);
//moisture level &pumping of water
if(sensor_data > 580)
{
    Serial.println("No moisture, Soil is dry");
     // Update LCD display  
    lcd.setCursor(0,0);
    lcd.print("Soil Dry, M ON");
    lcd.setCursor(0,1);
    lcd.print("Tem:");
    lcd.print(tempC);
    lcd.print(" hum:");
    lcd.print(humi);
    digitalWrite(Buzzer,HIGH);
    delay(100);
    digitalWrite(Buzzer,LOW);
    digitalWrite(LED_pin,HIGH);
    // Turn the pump on
    digitalWrite(relay_pin, LOW);
    delay(800);
    digitalWrite(relay_pin, HIGH);
    delay(3000);
    digitalWrite(LED_pin,LOW);    
}
  else if(sensor_data >= 400 && sensor_data <= 580)
  {
    Serial.println("There is some moisture, Soil is medium");
    digitalWrite(relay_pin, HIGH);
    lcd.setCursor(0,0);
    lcd.print("Soil Medium,M OFF");
    lcd.setCursor(0,1);
    lcd.print("Tem:");
    lcd.print(tempC);
    lcd.print(" hum:");
    lcd.print(humi);
      }
  else if(sensor_data < 400)
  {
    Serial.println("Soil is wet");
    digitalWrite(relay_pin, HIGH);
    lcd.setCursor(0,0);
    lcd.print("Soil Wet,M OFF  ");
    lcd.setCursor(0,1);
    lcd.print("Tem:");
    lcd.print(tempC);
    lcd.print(" hum:");
    lcd.print(humi);  
  }
  delay(5000);
  //ultrasonic sensor
 digitalWrite(trigPin,HIGH);
 delayMicroseconds(10);
 digitalWrite(trigPin,LOW);
 int duration_us=pulseIn(echoPin,HIGH);
 int distance_cm=0.017*duration_us;
 Serial.print("distance from base of water tank : ");
 Serial.print(distance_cm);
 Serial.print(" cm");
 Serial.print("\n");
 delay(500);
 if(distance_cm>13)
 {
  Serial.print("Water tank has less water !");
  Serial.print("\n");
  Serial.print("\n");
 }
 else{
  Serial.print("Water tank has sufficient water");
  Serial.print("\n");
  Serial.print("\n");
 }
}
//Code for Pest Detection
#include "esp_camera.h"
#include <WiFi.h>

// Camera Model Selection
#define CAMERA_MODEL_AI_THINKER // Has PSRAM
#include "camera_pins.h"

// WiFi Credentials
const char *ssid = "MINIPROJECT";
const char *password = "Mp@2024";

// IR Sensor and Buzzer Pins
#define IR_SENSOR_PIN 15
#define BUZZER 14

void startCameraServer();
void setupLedFlash(int pin);

void setup() {
  Serial.begin(115200);
  Serial.setDebugOutput(true);
  Serial.println();

  // Initialize IR Sensor and Buzzer
  pinMode(IR_SENSOR_PIN, INPUT);
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);

  // Camera Configuration
  camera_config_t config;
  config.ledc_channel = LEDC_CHANNEL_0;
  config.ledc_timer = LEDC_TIMER_0;
  config.pin_d0 = Y2_GPIO_NUM;
  config.pin_d1 = Y3_GPIO_NUM;
  config.pin_d2 = Y4_GPIO_NUM;
  config.pin_d3 = Y5_GPIO_NUM;
  config.pin_d4 = Y6_GPIO_NUM;
  config.pin_d5 = Y7_GPIO_NUM;
  config.pin_d6 = Y8_GPIO_NUM;
  config.pin_d7 = Y9_GPIO_NUM;
  config.pin_xclk = XCLK_GPIO_NUM;
  config.pin_pclk = PCLK_GPIO_NUM;
  config.pin_vsync = VSYNC_GPIO_NUM;
  config.pin_href = HREF_GPIO_NUM;
  config.pin_sccb_sda = SIOD_GPIO_NUM;
  config.pin_sccb_scl = SIOC_GPIO_NUM;
  config.pin_pwdn = PWDN_GPIO_NUM;
  config.pin_reset = RESET_GPIO_NUM;
  config.xclk_freq_hz = 20000000;
  config.pixel_format = PIXFORMAT_JPEG;
  config.frame_size = FRAMESIZE_SVGA;
  config.jpeg_quality = 12;
  config.fb_count = 1;

  if (psramFound()) {
    config.jpeg_quality = 10;
    config.fb_count = 2;
    config.grab_mode = CAMERA_GRAB_LATEST;
  } else {
    config.frame_size = FRAMESIZE_QVGA;
    config.fb_location = CAMERA_FB_IN_DRAM;
  }

  esp_err_t err = esp_camera_init(&config);
  if (err != ESP_OK) {
    Serial.printf("Camera init failed with error 0x%x\n", err);
    return;
  }

  sensor_t *s = esp_camera_sensor_get();
  if (s->id.PID == OV3660_PID) {
    s->set_vflip(s, 1);
    s->set_brightness(s, 1);
    s->set_saturation(s, -2);
  }
  s->set_framesize(s, FRAMESIZE_QVGA);

  WiFi.begin(ssid, password);
  WiFi.setSleep(false);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");

  startCameraServer();

  Serial.print("Camera Ready! Use 'http://");
  Serial.print(WiFi.localIP());
  Serial.println("' to connect");
}

void loop() {
  int irValue = digitalRead(IR_SENSOR_PIN);

  if (irValue == LOW) {
    Serial.println("Pest Detected!");
    digitalWrite(BUZZER, HIGH);
  } else {
    Serial.println("No Pest Detected.");
    digitalWrite(BUZZER, LOW);
  }

  delay(5000); // Check every 5 seconds
}

//Code for Plant Disease Classifier
import os
import json
from PIL import Image

import numpy as np
import tensorflow as tf
import streamlit as st


working_dir = os.path.dirname(os.path.abspath(__file__))
model_path = f"{working_dir}/trained_model/plant_disease_prediction_model.h5"
# Load the pre-trained model
model = tf.keras.models.load_model(model_path)

# loading the class names
class_indices = json.load(open(f"{working_dir}/class_indices.json"))


# Function to Load and Preprocess the Image using Pillow
def load_and_preprocess_image(image_path, target_size=(224, 224)):
    # Load the image
    img = Image.open(image_path)
    # Resize the image
    img = img.resize(target_size)
    # Convert the image to a numpy array
    img_array = np.array(img)
    # Add batch dimension
    img_array = np.expand_dims(img_array, axis=0)
    # Scale the image values to [0, 1]
    img_array = img_array.astype('float32') / 255.
    return img_array


# Function to Predict the Class of an Image
def predict_image_class(model, image_path, class_indices):
    preprocessed_img = load_and_preprocess_image(image_path)
    predictions = model.predict(preprocessed_img)
    predicted_class_index = np.argmax(predictions, axis=1)[0]
    predicted_class_name = class_indices[str(predicted_class_index)]
    return predicted_class_name


# Streamlit App
st.title('Plant Disease Classifier')

uploaded_image = st.file_uploader("Upload an image...", type=["jpg", "jpeg", "png"])

if uploaded_image is not None:
    image = Image.open(uploaded_image)
    col1, col2 = st.columns(2)

    with col1:
        resized_img = image.resize((150, 150))
        st.image(resized_img)

    with col2:
        if st.button('Classify'):
            # Preprocess the uploaded image and predict the class
            prediction = predict_image_class(model, uploaded_image, class_indices)
            st.success(f'Prediction: {str(prediction)}')

